bl_info = {
    "name": "Sapling Randomizer",
    "author": "Thomas Radeke",
    "version": (0, 1, 1),
    "blender": (2, 80, 0),
    "location": "View3D > Tool Shelf > Create",
    "description": "Generate multiple randomized \"Sapling\" curves at the same time.",
    "warning": "Needs the \"Sapling Tree Gen\" add-on to be activated.",
    "wiki_url": "https://github.com/ThomasRadeke/sapling-randomizer/wiki",
    "category": "Add Curve",
}

import os, bpy, random, math, add_curve_sapling
from bpy.props import *

class SaplingRandomizerOperator(bpy.types.Operator):
    bl_idname = "curve.sapling_randomizer"
    bl_label = "Sapling Randomizer"
    
    # Fix missing "bend" property in Sapling, which would otherwise prevent
    # execution of tree_add()
    add_curve_sapling.AddTree.bend = 0.0
    
    # get Sapling presets
    script_paths = bpy.utils.script_paths()
    sapling_presets_path = ''
    # bpy.utils.script_paths() returns a list, so we have to go through every entry if we want to find the right path
    for p in script_paths:
        sapling_presets_path = os.path.join(p, 'addons', 'add_curve_sapling', 'presets')
        if(os.path.isdir(sapling_presets_path)):
            #print(sapling_presets_path)
            #print(os.listdir(sapling_presets_path))
            # Get all the sapling preset filenames
            sapling_presets = [a for a in os.listdir(sapling_presets_path) if a[-3:] == '.py']
            
    # Prepare enum item list from filenames
    preset_items = []
    for s in sapling_presets:
        preset_items.append((s, s, 'Use "'+s+'" as preset'))
    
    # Define class properties that will show up as UI elements on the dialog
    presets = EnumProperty(name="Preset", description="", items=preset_items)
    num_trees = IntProperty(name="Number of Saplings", description="Number of trees that will be generated by Sapling", default=10, min=1)
    spread = FloatProperty(name="Spread", description="Area in which Saplings will be created", unit='LENGTH')
    relative_spread = BoolProperty(name="Relative Spread", description="Make spread depend on number of Saplings", default=True)
    randomseed = IntProperty(name="Random Seed", description="Starting seed that will be passed to Sapling when generating trees", default=0)
    max_branch_levels = IntProperty(name="Maximum Branch Levels", description="Maximum branch levels to import from the preset", default=2) 
    show_leaves = BoolProperty(name="Generate Leaves", description="Generate leaves for all generated Saplings", default=True)
    # leaf shape enum copied directly from Sapling.
    leaf_shape = EnumProperty(name="Leaf Shape", items=(('hex', 'Hexagonal', '0'), ('rect', 'Rectangular', '1'),
               ('dFace', 'DupliFaces', '2'), ('dVert', 'DupliVerts', '3')), default='hex')
    
    # Run the actual code upon pressing "OK" on the dialog
    def execute(self, context):
        
        # decide whether "spread" will be relative or absolute
        if self.relative_spread:
            spread = math.sqrt(self.num_trees)*self.spread
        else:
            spread = self.spread
        
        # get window_manager context to make updating the progress indicator less code
        wm = bpy.context.window_manager
        
        # start up the random generator with a new seed
        random.seed(self.randomseed)
        
        # start progress indicator
        wm.progress_begin(0, self.num_trees)
        
        # generate a number of trees
        for s in range(0, self.num_trees):
            #add_curve_sapling.ImportData.filename = 'japanese_maple.py'
            
            # use Sapling's own ImportData class to read the preset files into the "settings" list
            add_curve_sapling.ImportData.filename = self.presets
            add_curve_sapling.ImportData.execute(add_curve_sapling.ImportData, bpy.context)
            
            # have to override the preset values after reading them
            if add_curve_sapling.settings["levels"] > self.max_branch_levels:
                add_curve_sapling.settings["levels"] = self.max_branch_levels
            add_curve_sapling.settings["limitImport"] = False
            add_curve_sapling.settings["do_update"] = True
            add_curve_sapling.settings["bevel"] = True
            add_curve_sapling.settings["prune"] = False
            add_curve_sapling.settings["showLeaves"] = self.show_leaves
            add_curve_sapling.settings["leafShape"] = self.leaf_shape
            add_curve_sapling.settings["useArm"] = False
            add_curve_sapling.settings["seed"] = self.randomseed+s
            
            # run the actual tree generating code
            obj = bpy.ops.curve.tree_add(
                limitImport=False,
                do_update=True,
                bevel=True,
                prune=False,
                showLeaves=self.show_leaves,
                leafShape=self.leaf_shape,
                useArm=False,
                seed=self.randomseed+s
            )
            # update the progress indicator after each tree
            wm.progress_update(s)
            
        # tell the progress indicator we're finished
        wm.progress_end()
        
        # since we cannot tell Sapling where to put its new trees, we have to iterate through all "tree" objects
        # and move them randomly after generating them
        for obj in bpy.context.scene.objects:
            #print(obj.name, obj, obj.type)
            if(obj.type == 'CURVE') and ("tree" in obj.name):
                x = (random.random() * spread) - spread/2
                y = (random.random() * spread) - spread/2
                obj.location = (x, y, 0)
        return {'FINISHED'}
    
    # update the dialog when checkboxes are used
    #def check(self, context):
    #    return True
    
    # set some defaults before popping up the dialog, then pop up the dialog
    def invoke(self, context, event):
        self.num_trees = 10
        self.randomseed = 0
        self.leaf_shape='hex'
        self.relative_spread = True
        self.spread = 3.0
        return context.window_manager.invoke_props_dialog(self)

# register the operator so it can be called from the class below
bpy.utils.register_class(SaplingRandomizerOperator)

# make an entry in the UI so the randomizer can be called with a button
# instead of just the quick menu
class SaplingRandomizer(bpy.types.Panel):
    bl_label = "Sapling Randomizer"
    bl_space_type = "VIEW_3D"
    bl_region_type = 'TOOLS' if bpy.app.version < (2, 80) else 'UI'
    #bl_region_type = "UI"
    bl_category = "Create"
    bl_context = "objectmode"
    
    def draw(self, context):
        layout = self.layout
        
        row = layout.row()
        row.operator("curve.sapling_randomizer")
    
def register():
    bpy.utils.register_class(SaplingRandomizer)
    
def unregister():
    bpy.utils.unregister_class(SaplingRandomizer)
    
if __name__ == "__main__":
    register()
